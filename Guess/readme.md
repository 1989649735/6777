# 猜数字游戏：单人本地增强版 - 伪代码实现

## 📋 项目概述

### 核心功能需求
1. **基础猜数字**：支持经典猜数字游戏
2. **多种难度模式**：实现5种不同的游戏模式
3. **本地数据存储**：使用localStorage保存游戏数据
4. **进度与成就**：追踪玩家进度和解锁成就
5. **自适应难度**：根据玩家表现调整游戏难度

## 🏗️ 系统架构设计

### 模块结构
```
main.js                # 游戏主入口
├── GameEngine.js      # 游戏逻辑核心
├── StorageManager.js  # 本地存储管理
├── UIManager.js       # 界面控制器
├── AchievementSystem.js # 成就系统
└── ConfigManager.js   # 配置管理
```

## 🎮 核心模块伪代码实现

### 1. 游戏引擎 (GameEngine.js)

```pseudocode
模块：GameEngine
职责：核心游戏逻辑控制

数据结构：
  游戏状态 = {
    游戏ID: 字符串,
    模式: 字符串,
    难度: 字符串,
    目标值: 数字或数组,
    当前尝试次数: 整数,
    最大尝试次数: 整数,
    已用时间: 毫秒,
    游戏结束: 布尔值,
    胜利: 布尔值,
    猜测历史: 数组[{
      猜测值: 数字或数组,
      反馈: 字符串,
      时间戳: 毫秒
    }],
    特殊规则: 对象
  }

常量：
  游戏模式 = {
    经典: "classic",
    多数字: "multi",
    数学运算: "math",
    反向提示: "reverse",
    动态调整: "dynamic",
    密码破译: "code"
  }

函数：初始化游戏(模式, 难度, 自定义配置)
  输入：模式字符串，难度字符串，可选配置对象
  输出：游戏状态对象
  
  步骤：
    1. 创建新的游戏状态对象
    2. 设置游戏ID为当前时间戳
    3. 根据模式选择生成目标值：
       如果 模式 == "classic" 或 "reverse" 或 "dynamic":
         目标值 = 生成随机数(最小范围, 最大范围)
         如果 使用小数模式:
           目标值 = 目标值 + 随机小数(小数位数)
       
       如果 模式 == "multi":
         目标值 = 空数组
         循环 i 从 1 到 数字数量:
           数字 = 生成随机数(最小范围, 最大范围)
           目标值.添加(数字)
       
       如果 模式 == "math":
         原始值 = 生成随机数(1, 50)
         目标值 = 应用运算(原始值, 运算类型)  # 如：×2, +10等
       
       如果 模式 == "code":
         目标值 = 空数组
         循环 i 从 1 到 密码长度:
           数字 = 生成随机数(0, 9)
           目标值.添加(数字)
     
    4. 根据难度设置最大尝试次数：
       如果 难度 == "简单": 最大尝试次数 = 15
       如果 难度 == "中等": 最大尝试次数 = 10
       如果 难度 == "困难": 最大尝试次数 = 7
       如果 难度 == "专家": 最大尝试次数 = 5
     
    5. 初始化特殊规则（如时间限制、惩罚机制等）
    6. 返回游戏状态

函数：处理猜测(游戏状态, 玩家输入)
  输入：当前游戏状态，玩家的猜测值
  输出：更新后的游戏状态和反馈信息
  
  步骤：
    1. 验证输入有效性：
       如果 模式 == "classic" 或 "reverse" 或 "dynamic" 或 "math":
         如果 玩家输入不是数字 或 不在范围内:
           返回错误："请输入有效数字"
       
       如果 模式 == "multi":
         如果 玩家输入不是数组 或 长度不正确:
           返回错误："请输入正确的数字组合"
         循环 检查每个数字的有效性
       
       如果 模式 == "code":
         如果 玩家输入不是字符串 或 长度不正确 或 包含非数字:
           返回错误："请输入4位数字密码"
     
    2. 增加当前尝试次数
    3. 根据模式计算反馈：
       
       如果 模式 == "classic":
         如果 玩家输入 == 目标值:
           反馈 = "正确！"
           游戏结束 = true
           胜利 = true
         否则 如果 玩家输入 < 目标值:
           反馈 = "太小了"
         否则:
           反馈 = "太大了"
       
       如果 模式 == "multi":
         反馈 = 空字符串
         全部正确 = true
         循环 i 从 0 到 目标值长度-1:
           如果 玩家输入[i] == 目标值[i]:
             反馈 = 反馈 + "数字" + (i+1) + "正确；"
           否则 如果 玩家输入[i] < 目标值[i]:
             反馈 = 反馈 + "数字" + (i+1) + "太小；"
             全部正确 = false
           否则:
             反馈 = 反馈 + "数字" + (i+1) + "太大；"
             全部正确 = false
         
         如果 全部正确:
           游戏结束 = true
           胜利 = true
       
       如果 模式 == "math":
         计算值 = 应用运算(玩家输入, 运算类型)
         如果 计算值 == 目标值:
           反馈 = "正确！运算结果匹配"
           游戏结束 = true
           胜利 = true
         否则 如果 计算值 < 目标值:
           反馈 = "运算结果太小"
         否则:
           反馈 = "运算结果太大"
       
       如果 模式 == "reverse":
         差值 = 绝对值(玩家输入 - 目标值)
         如果 差值 == 0:
           反馈 = "正确！"
           游戏结束 = true
           胜利 = true
         否则 如果 差值 <= 10:
           反馈 = "比目标值大10以内" 或 "比目标值小10以内"
         否则 如果 是目标值的约数:
           反馈 = "是目标的约数"
         否则 如果 差值是质数:
           反馈 = "与目标的差是质数"
         否则:
           反馈 = "没有任何特殊关系"
       
       如果 模式 == "dynamic":
         # 目标值可能发生变化
         如果 随机数() < 0.2:  # 20%概率变化
           变化量 = 随机整数(-5, 5)
           目标值 = 限制范围(目标值 + 变化量, 最小范围, 最大范围)
         
         如果 玩家输入 == 目标值:
           反馈 = "正确！"
           游戏结束 = true
           胜利 = true
         否则 如果 玩家输入 < 目标值:
           反馈 = "太小了"
         否则:
           反馈 = "太大了"
       
       如果 模式 == "code":
         位置正确 = 0
         数字正确 = 0
         已匹配目标 = 空数组
         已匹配猜测 = 空数组
         
         # 首先检查位置正确的
         循环 i 从 0 到 目标值长度-1:
           如果 玩家输入[i] == 目标值[i]:
             位置正确 = 位置正确 + 1
             已匹配目标.添加(i)
             已匹配猜测.添加(i)
         
         # 检查数字正确但位置错误的
         循环 i 从 0 到 目标值长度-1:
           如果 i 不在 已匹配目标:
             循环 j 从 0 到 玩家输入长度-1:
               如果 j 不在 已匹配猜测 且 玩家输入[j] == 目标值[i]:
                 数字正确 = 数字正确 + 1
                 已匹配目标.添加(i)
                 已匹配猜测.添加(j)
                 跳出内层循环
         
         反馈 = 位置正确 + "A" + 数字正确 + "B"
         如果 位置正确 == 目标值长度:
           游戏结束 = true
           胜利 = true
     
    4. 检查游戏结束条件：
       如果 当前尝试次数 >= 最大尝试次数:
         游戏结束 = true
         胜利 = false
         反馈 = "游戏结束！正确答案是：" + 目标值
     
    5. 将猜测记录添加到历史
    6. 返回更新后的游戏状态和反馈

函数：获取提示(游戏状态)
  输入：当前游戏状态
  输出：提示信息字符串
  
  步骤：
    1. 检查是否还有提示次数
    2. 根据模式和当前状态生成提示：
       
       如果 模式 == "classic":
         如果 当前尝试次数 == 0:
           返回 "目标在 " + 最小范围 + " 和 " + 最大范围 + " 之间"
         否则:
           最近猜测 = 猜测历史[最后一项]
           如果 最近猜测.反馈 == "太小了":
              返回 "目标大于 " + 最近猜测.猜测值
           否则 如果 最近猜测.反馈 == "太大了":
              返回 "目标小于 " + 最近猜测.猜测值
       
       如果 模式 == "math":
         返回 "目标 = 你的猜测 " + 运算符号 + " X"
       
       如果 模式 == "reverse":
         返回 "目标是" + (目标值是偶数 ? "偶数" : "奇数")
       
       其他模式:
         返回 "此模式暂无提示"
     
    3. 减少剩余提示次数
    4. 保存更新后的游戏状态
```

### 2. 存储管理器 (StorageManager.js)

```pseudocode
模块：StorageManager
职责：管理本地存储和玩家数据

常量：
  存储键 = {
    玩家数据: "guessNumber_playerData_v2",
    游戏历史: "guessNumber_gameHistory",
    成就状态: "guessNumber_achievements",
    游戏设置: "guessNumber_settings",
    当前游戏: "guessNumber_currentGame"
  }

数据结构：
  玩家数据 = {
    玩家ID: 字符串,          # 基于时间戳生成
    统计信息: {
      总游戏数: 整数,
      胜利数: 整数,
      平均尝试次数: 数字,
      最快胜利时间: 毫秒,
      最高连胜: 整数,
      各模式统计: 对象
    },
    技能等级: 整数(1-10),
    解锁的模式: 数组[字符串],
    最后游戏时间: 时间戳
  }

函数：初始化存储()
  步骤：
    1. 如果 localStorage 中没有玩家数据:
        创建默认玩家数据
        保存到 localStorage
    2. 如果 localStorage 中没有游戏设置:
        创建默认设置
        保存到 localStorage

函数：保存玩家数据(玩家数据对象)
  输入：玩家数据对象
  步骤：
    1. 获取现有玩家数据
    2. 合并新数据到现有数据
    3. 添加时间戳
    4. 压缩数据（可选）
    5. 序列化为JSON字符串
    6. localStorage.setItem(存储键.玩家数据, JSON字符串)

函数：加载玩家数据()
  输出：玩家数据对象
  步骤：
    1. 从 localStorage 获取JSON字符串
    2. 如果 数据存在:
        解析JSON
        返回玩家数据对象
    3. 否则:
        返回默认玩家数据

函数：保存游戏记录(游戏状态)
  输入：游戏状态对象
  步骤：
    1. 从 localStorage 加载游戏历史
    2. 创建记录 = {
        游戏ID: 游戏状态.游戏ID,
        模式: 游戏状态.模式,
        难度: 游戏状态.难度,
        结果: 游戏状态.胜利 ? "胜利" : "失败",
        尝试次数: 游戏状态.当前尝试次数,
        用时: 游戏状态.已用时间,
        目标值: 游戏状态.目标值,
        时间戳: 当前时间戳
      }
    3. 将记录添加到历史数组
    4. 如果 历史数组长度 > 100:
        移除最旧的记录
    5. 保存到 localStorage

函数：保存当前游戏(游戏状态)
  输入：游戏状态对象
  步骤：
    1. 序列化游戏状态为JSON
    2. localStorage.setItem(存储键.当前游戏, JSON字符串)

函数：加载当前游戏()
  输出：游戏状态对象 或 null
  步骤：
    1. 从 localStorage 获取JSON字符串
    2. 如果 数据存在:
        解析JSON
        返回游戏状态对象
    3. 否则:
        返回 null

函数：清除当前游戏()
  步骤：
    localStorage.removeItem(存储键.当前游戏)

函数：导出玩家数据()
  输出：JSON字符串
  步骤：
    1. 收集所有相关数据：
       玩家数据
       游戏历史
       成就状态
       游戏设置
    2. 添加导出时间戳和版本号
    3. 返回JSON字符串

函数：导入玩家数据(JSON字符串)
  输入：JSON字符串
  输出：布尔值（是否成功）
  步骤：
    1. 解析JSON字符串
    2. 验证数据结构
    3. 如果 验证通过:
        更新所有本地存储项
        返回 true
    4. 否则:
        返回 false
```

### 3. 成就系统 (AchievementSystem.js)

```pseudocode
模块：AchievementSystem
职责：管理和追踪游戏成就

数据结构：
  成就 = {
    id: 字符串,            # 唯一标识符
    name: 字符串,          # 成就名称
    description: 字符串,    # 成就描述
    icon: 字符串,          # 图标名称或路径
    points: 整数,          # 成就点数
    category: 字符串,      # 类别：里程碑、技能、收集、挑战
    hidden: 布尔值,        # 是否隐藏（直到解锁）
    criteria: 函数,        # 解锁条件检查函数
    progress: {            # 进度跟踪（用于多阶段成就）
      current: 整数,
      target: 整数
    },
    unlocked: 布尔值,      # 是否已解锁
    unlockDate: 时间戳     # 解锁时间
  }

常量：
  成就列表 = [
    {
      id: "first_win",
      name: "初战告捷",
      description: "赢得第一场游戏",
      category: "里程碑",
      criteria: 函数(游戏记录, 玩家数据):
        返回 玩家数据.统计信息.胜利数 >= 1
    },
    {
      id: "perfect_guess",
      name: "一次命中",
      description: "第一次尝试就猜中数字",
      category: "技能",
      criteria: 函数(游戏记录, 玩家数据):
        返回 游戏记录.尝试次数 == 1 且 游戏记录.结果 == "胜利"
    },
    {
      id: "speed_demon",
      name: "速度之星",
      description: "在30秒内完成游戏",
      category: "技能",
      criteria: 函数(游戏记录, 玩家数据):
        返回 游戏记录.用时 <= 30000 且 游戏记录.结果 == "胜利"
    },
    {
      id: "master_of_all",
      name: "全能大师",
      description: "在所有游戏模式中都获得胜利",
      category: "收集",
      criteria: 函数(游戏记录, 玩家数据):
        必要模式 = ["classic", "multi", "math", "reverse", "dynamic", "code"]
        已胜利模式 = 空集合
        循环 游戏历史中的每条记录:
          如果 记录.结果 == "胜利":
            已胜利模式.添加(记录.模式)
        返回 必要模式.长度 == 已胜利模式.长度
    },
    {
      id: "code_breaker",
      name: "密码破译专家",
      description: "在密码破译模式中连续胜利3次",
      category: "挑战",
      progress: { current: 0, target: 3 },
      criteria: 函数(游戏记录, 玩家数据):
        如果 游戏记录.模式 == "code" 且 游戏记录.结果 == "胜利":
          成就.进度.current = 成就.进度.current + 1
        返回 成就.进度.current >= 成就.进度.target
    }
  ]

函数：初始化成就系统()
  步骤：
    1. 从 localStorage 加载已解锁成就
    2. 如果 没有数据:
        创建初始成就状态（全部未解锁）
        保存到 localStorage

函数：检查成就(游戏记录)
  输入：游戏记录对象
  步骤：
    1. 加载成就状态
    2. 循环 成就列表:
        如果 成就未解锁:
          调用 成就.criteria(游戏记录, 玩家数据)
          如果 返回true:
            解锁成就(成就.id)
            触发成就解锁事件(成就)
    3. 保存更新后的成就状态

函数：解锁成就(成就ID)
  输入：成就ID字符串
  步骤：
    1. 找到对应的成就
    2. 设置成就.unlocked = true
    3. 设置成就.unlockDate = 当前时间戳
    4. 更新玩家总成就点数
    5. 保存到 localStorage
    6. 返回解锁的成就对象

函数：获取成就进度()
  输出：成就进度对象
  步骤：
    1. 加载成就状态
    2. 计算：
       总成就数 = 成就列表.长度
       已解锁数 = 成就列表中 成就.unlocked == true 的数量
       总点数 = 成就列表中 成就.unlocked == true 的成就.points 的总和
       各分类进度 = 按category分组统计
    3. 返回进度对象

函数：重置成就()
  步骤：
    1. 循环 成就列表:
        设置成就.unlocked = false
        清除成就.unlockDate
        重置成就.progress.current = 0
    2. 保存到 localStorage
```

### 4. 用户界面管理器 (UIManager.js)

```pseudocode
模块：UIManager
职责：管理游戏界面和用户交互

常量：
  界面状态 = {
    主菜单: "main_menu",
    游戏进行中: "playing",
    游戏结束: "game_over",
    设置: "settings",
    统计: "stats",
    成就: "achievements"
  }

函数：初始化界面()
  步骤：
    1. 获取DOM元素引用：
       游戏容器、输入框、按钮、显示区域等
    2. 设置事件监听器：
       猜测提交按钮点击
       输入框回车键
       菜单按钮点击
       设置变更
    3. 加载当前游戏状态（如果有）
    4. 更新界面到相应状态

函数：渲染游戏界面(游戏状态)
  输入：游戏状态对象
  步骤：
    1. 清空游戏显示区域
    2. 显示游戏信息：
       模式名称
       当前尝试次数/最大尝试次数
       剩余时间（如果有时限）
       温度指示器（如果启用）
    3. 显示猜测历史：
       循环 游戏状态.猜测历史:
         创建历史项元素
         显示猜测值、反馈、时间
         添加到历史列表
    4. 显示输入区域：
       根据模式显示相应输入控件
       经典/数学/反向/动态：数字输入框
       多数字：多个数字输入框
       密码：密码输入框（显示为*）
    5. 设置输入框焦点

函数：显示反馈(反馈信息, 反馈类型)
  输入：反馈字符串，类型字符串（"success"/"error"/"info"）
  步骤：
    1. 创建反馈元素
    2. 根据类型设置样式：
       成功：绿色背景
       错误：红色背景
       信息：蓝色背景
    3. 显示反馈文本
    4. 3秒后自动淡出（或用户点击后关闭）

函数：显示游戏结果(游戏状态)
  输入：游戏状态对象
  步骤：
    1. 创建结果弹窗
    2. 如果 游戏状态.胜利:
       显示胜利消息
       显示胜利动画
       显示统计信息：
         尝试次数
         用时
         分数计算
       显示解锁的成就（如果有）
    3. 否则:
       显示失败消息
       显示正确答案
       显示鼓励信息
    4. 显示操作按钮：
       重新开始（相同模式）
       返回主菜单
       分享结果（生成分享文本）

函数：更新统计显示(玩家数据)
  输入：玩家数据对象
  步骤：
    1. 计算关键指标：
       胜率 = (胜利数 / 总游戏数) × 100
       平均尝试次数
       最快时间
       当前连胜
    2. 更新统计面板显示
    3. 生成统计图表（使用简单HTML/CSS或Canvas）

函数：显示成就页面()
  步骤：
    1. 获取成就状态
    2. 创建成就网格
    3. 循环 成就列表:
       创建成就卡片
       如果 已解锁:
         显示成就详情
         显示解锁日期
         显示成就点数
       否则 如果 是隐藏成就:
         显示"？？？"（隐藏详情）
       否则:
         显示成就描述（但灰显）
    4. 显示总成就点数
    5. 显示完成进度

函数：显示设置面板()
  步骤：
    1. 从存储加载设置
    2. 创建设置表单：
       游戏难度选择
       提示设置（启用/禁用，每局次数）
       界面主题（深色/浅色）
       音效设置
       数据管理（导出/导入/重置）
    3. 设置表单值变化监听器
    4. 保存设置到存储

函数：处理输入验证(输入值, 游戏模式)
  输入：用户输入，游戏模式字符串
  输出：验证结果对象
  步骤：
    1. 根据模式验证：
       经典模式：检查是否为数字且在范围内
       多数字模式：检查每个数字
       密码模式：检查长度和字符
    2. 返回 {
        有效: 布尔值,
        错误信息: 字符串（如果无效）,
        格式化输入: 处理后的值
      }
```

### 5. 配置管理器 (ConfigManager.js)

```pseudocode
模块：ConfigManager
职责：管理游戏配置和难度设置

数据结构：
  游戏配置 = {
    模式配置: {
      经典: {
        名称: "经典猜数字",
        描述: "传统的猜数字游戏",
        难度级别: {
          简单: { 范围: [1, 50], 最大尝试次数: 15 },
          中等: { 范围: [1, 100], 最大尝试次数: 10 },
          困难: { 范围: [1, 200], 最大尝试次数: 7 },
          专家: { 范围: [1, 1000], 最大尝试次数: 5, 使用小数: true }
        }
      },
      多数字: {
        名称: "多数字组合",
        描述: "同时猜测多个数字",
        难度级别: {
          简单: { 数字数量: 2, 范围: [1, 20], 最大尝试次数: 15 },
          中等: { 数字数量: 3, 范围: [1, 30], 最大尝试次数: 12 },
          困难: { 数字数量: 4, 范围: [1, 40], 最大尝试次数: 10 }
        }
      },
      数学运算: {
        名称: "数学运算",
        描述: "通过运算接近目标",
        难度级别: {
          简单: { 运算: "×2", 范围: [1, 50], 最大尝试次数: 12 },
          中等: { 运算: "×3", 范围: [1, 100], 最大尝试次数: 10 },
          困难: { 运算: "平方", 范围: [1, 20], 最大尝试次数: 8 }
        }
      },
      反向提示: {
        名称: "反向提示",
        描述: "通过特殊提示推理目标",
        难度级别: {
          简单: { 范围: [1, 50], 最大尝试次数: 12, 提示类型: ["大小10以内"] },
          中等: { 范围: [1, 100], 最大尝试次数: 10, 提示类型: ["大小10以内", "约数"] },
          困难: { 范围: [1, 200], 最大尝试次数: 8, 提示类型: ["大小10以内", "约数", "质数差"] }
        }
      },
      动态调整: {
        名称: "动态目标",
        描述: "目标数字会随机变化",
        难度级别: {
          简单: { 范围: [1, 50], 最大尝试次数: 15, 变化概率: 0.1 },
          中等: { 范围: [1, 100], 最大尝试次数: 12, 变化概率: 0.2 },
          困难: { 范围: [1, 200], 最大尝试次数: 10, 变化概率: 0.3 }
        }
      },
      密码破译: {
        名称: "密码破译",
        描述: "猜数字和位置",
        难度级别: {
          简单: { 密码长度: 3, 数字范围: [0, 5], 最大尝试次数: 12 },
          中等: { 密码长度: 4, 数字范围: [0, 7], 最大尝试次数: 10 },
          困难: { 密码长度: 5, 数字范围: [0, 9], 最大尝试次数: 8 }
        }
      }
    },
    用户设置: {
      难度: "中等",
      主题: "light",
      音效: true,
      动画: true,
      自动保存: true,
      提示设置: {
        启用: true,
        每局最大提示: 3
      }
    },
    解锁要求: {
      多数字: { 要求: "经典模式胜利5次" },
      数学运算: { 要求: "经典模式胜利10次" },
      反向提示: { 要求: "多数字模式胜利3次" },
      动态调整: { 要求: "数学运算模式胜利3次" },
      密码破译: { 要求: "所有其他模式各胜利1次" }
    }
  }

函数：获取模式配置(模式名称, 难度级别)
  输入：模式名称字符串，难度级别字符串
  输出：模式配置对象
  步骤：
    1. 检查模式是否存在
    2. 检查难度级别是否存在
    3. 返回 游戏配置.模式配置[模式名称].难度级别[难度级别]

函数：检查模式解锁(模式名称, 玩家数据)
  输入：模式名称字符串，玩家数据对象
  输出：布尔值
  步骤：
    1. 获取解锁要求
    2. 如果 没有解锁要求 或 模式已在玩家数据.解锁的模式中:
        返回 true
    3. 解析要求条件：
       如果 要求 == "经典模式胜利5次":
         经典胜利 = 统计游戏历史中模式=="经典"且结果=="胜利"的数量
         返回 经典胜利 >= 5
       如果 要求 == "所有其他模式各胜利1次":
         必要模式 = ["经典", "多数字", "数学运算", "反向提示", "动态调整"]
         循环 必要模式:
           如果 模式 != 模式名称:
              胜利次数 = 统计该模式的胜利次数
              如果 胜利次数 < 1:
                返回 false
         返回 true
    4. 如果 满足条件:
        将模式添加到玩家数据.解锁的模式
        保存玩家数据
        返回 true
    5. 否则:
        返回 false

函数：获取推荐难度(玩家数据, 模式名称)
  输入：玩家数据对象，模式名称字符串
  输出：难度级别字符串
  步骤：
    1. 获取玩家在该模式的历史表现
    2. 计算胜率
    3. 根据胜率推荐难度：
       如果 胜率 > 80%: 推荐 "困难"
       否则 如果 胜率 > 60%: 推荐 "中等"
       否则: 推荐 "简单"
    4. 返回推荐难度

函数：更新用户设置(新设置)
  输入：设置对象
  步骤：
    1. 获取当前设置
    2. 合并新设置
    3. 验证设置有效性
    4. 保存到 localStorage
    5. 应用设置到界面（如主题切换）

函数：重置为默认设置()
  步骤：
    1. 加载默认设置
    2. 保存到 localStorage
    3. 返回默认设置对象
```

### 6. 主程序入口 (main.js)

```pseudocode
模块：Main
职责：协调各模块，启动游戏

函数：初始化游戏()
  步骤：
    1. 初始化存储管理器
    2. 初始化配置管理器
    3. 初始化成就系统
    4. 初始化用户界面
    5. 加载玩家数据
    6. 检查是否有保存的游戏：
       如果有:
         询问是否继续
         如果 是:
           加载保存的游戏
           切换到游戏界面
       否则:
         显示主菜单

函数：开始新游戏(模式, 难度)
  输入：模式名称，难度级别
  步骤：
    1. 检查模式是否解锁
    2. 如果 未解锁:
         显示解锁要求
         返回
    3. 创建游戏引擎实例
    4. 获取模式配置
    5. 初始化游戏状态
    6. 保存当前游戏状态
    7. 切换到游戏界面
    8. 开始计时

函数：处理游戏循环()
  步骤：
    1. 获取当前游戏状态
    2. 如果 游戏有時間限制:
         计算剩余时间
         更新界面显示
         如果 时间到:
           结束游戏(失败)
    3. 如果 游戏状态.游戏结束:
         处理游戏结束
         返回
    4. 等待用户输入
    5. 当用户提交猜测:
         验证输入
         处理猜测
         更新界面
         保存游戏状态
         如果 游戏结束:
           更新玩家数据
           保存游戏记录
           检查成就
           显示结果

函数：保存游戏进度()
  步骤：
    1. 获取当前游戏状态
    2. 如果 游戏状态.游戏结束:
         不需要保存
         返回
    3. 存储管理器.保存当前游戏(游戏状态)
    4. 显示保存成功提示

函数：退出游戏()
  步骤：
    1. 保存游戏进度（如果启用自动保存）
    2. 停止所有计时器
    3. 清除当前游戏状态
    4. 切换到主菜单

函数：显示主菜单()
  步骤：
    1. 显示游戏标题
    2. 显示可用的游戏模式：
       循环 所有模式:
         如果 模式已解锁:
           显示模式按钮
           显示模式描述
         否则:
           显示锁定状态
           显示解锁要求
    3. 显示其他选项：
       继续游戏（如果有）
       统计信息
       成就
       设置
       退出
    4. 设置按钮点击事件

// 事件处理函数
当 页面加载完成:
  调用 初始化游戏()

当 用户点击"开始游戏":
  模式 = 获取选择的模式
  难度 = 获取选择的难度 或 使用推荐难度
  调用 开始新游戏(模式, 难度)

当 用户点击"提交猜测":
  输入值 = 获取输入框的值
  调用 游戏引擎.处理猜测(当前游戏状态, 输入值)

当 用户点击"提示":
  调用 游戏引擎.获取提示(当前游戏状态)

当 用户点击"设置":
  调用 UIManager.显示设置面板()

当 设置变更:
  调用 ConfigManager.更新用户设置(新设置)

当 窗口即将关闭:
  调用 保存游戏进度()
```

## 📁 文件存储结构

```
guess-number-game/
├── index.html          # 主HTML文件
├── css/
│   ├── style.css       # 主样式
│   ├── themes.css      # 主题样式
│   └── animations.css  # 动画样式
├── js/
│   ├── main.js         # 主程序入口
│   ├── GameEngine.js
│   ├── StorageManager.js
│   ├── UIManager.js
│   ├── AchievementSystem.js
│   └── ConfigManager.js
├── assets/
│   ├── icons/          # 图标资源
│   └── sounds/         # 音效资源
└── README.md           # 游戏说明
```

## 🚀 启动流程

1. **页面加载**：
   - 初始化所有模块
   - 检查本地存储数据
   - 显示主菜单

2. **开始游戏**：
   - 选择模式 → 检查解锁 → 选择难度 → 开始游戏

3. **游戏进行**：
   - 显示游戏界面
   - 处理用户输入
   - 实时更新状态

4. **游戏结束**：
   - 显示结果
   - 更新统计数据
   - 检查成就解锁
   - 返回主菜单或重新开始

这个设计提供了完整的单人猜数字游戏系统，支持多种游戏模式、本地存储和进度追踪。所有模块都可以独立开发和测试，便于维护和扩展。